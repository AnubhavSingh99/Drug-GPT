// This file is generated by Firebase Genkit.
'use server';
/**
 * @fileOverview An AI agent for analyzing drug candidates.
 *
 * - analyzeDrugCandidate - A function that handles the drug candidate analysis process.
 * - AnalyzeDrugCandidateInput - The input type for the analyzeDrugCandidate function.
 * - AnalyzeDrugCandidateOutput - The return type for the analyzeDrugCandidate function.
 */

import { ai } from '@/ai/ai-instance';
import { z } from 'genkit';
import { getMoleculeBySmiles, type Molecule } from '@/services/pubchem';
import { getDrugByName, type Drug, DrugSchema } from '@/services/drugbank'; // Import Drug type and schema
import { getDeepPurposeAnalysis, type DeepPurposeResult, DeepPurposeResultSchema } from '@/services/deeppurpose'; // Import DeepPurpose types and schema

// Define input schema (remains the same)
const AnalyzeDrugCandidateInputSchema = z.object({
  smiles: z
    .string()
    .describe('The SMILES string of the drug candidate.'),
  targetProtein: z
    .string()
    .optional()
    .describe('The optional target protein for the analysis.'),
  query: z.string().describe('The analysis query from the user.'),
});
export type AnalyzeDrugCandidateInput = z.infer<typeof AnalyzeDrugCandidateInputSchema>;


// Define the structured output schema
const AnalyzeDrugCandidateOutputSchema = z.object({
  synthesizedAnalysis: z.string().describe('The overall synthesized analysis addressing the user query, incorporating information from all relevant tools used.'),
  drugBankData: z.nullable(DrugSchema).describe('Information retrieved from DrugBank, if applicable.'),
  deepPurposeData: z.nullable(DeepPurposeResultSchema).describe('Prediction results from the DeepPurpose analysis.'),
  // We fetch PubChem data separately in the component now, so no need to return it from the flow.
  // pubChemData: z.nullable(PubChemSchema).describe('Information retrieved from PubChem.'),
});
export type AnalyzeDrugCandidateOutput = z.infer<typeof AnalyzeDrugCandidateOutputSchema>;


// Define tools (remain the same)
const pubChemTool = ai.defineTool({
  name: 'getMoleculeBySmiles',
  description: 'Retrieves basic molecule information (CID, formula, IUPAC name, canonical SMILES, molecular weight) from PubChem based on a SMILES string. Should be the first step for chemical data gathering.',
  inputSchema: z.object({
    smiles: z.string().describe('The SMILES string of the molecule to search for.'),
  }),
  outputSchema: z.object({
    cid: z.number().describe('The PubChem CID (Compound Identifier).'),
    molecularFormula: z.string().describe('The molecular formula.'),
    iupacName: z.string().optional().describe('The IUPAC name, if available.'),
    canonicalSmiles: z.string().describe('The canonical SMILES string.'),
    molecularWeight: z.number().describe('The molecular weight.'),
  }),
},
async input => {
  const molecule = await getMoleculeBySmiles(input.smiles);
  return molecule;
});

const drugBankTool = ai.defineTool({
  name: 'getDrugByName',
  description: 'Retrieves known drug information from DrugBank based on a drug name. Use this tool if the molecule identified by PubChem has an IUPAC name that suggests it might be a known drug, or if the user\'s query explicitly mentions a drug name.',
  inputSchema: z.object({
    drugName: z.string().describe('The name of the drug to search for in DrugBank.'),
  }),
  outputSchema: DrugSchema, // Use the exported schema
},
async input => {
  const drug = await getDrugByName(input.drugName);
  return drug;
});

const deepPurposeTool = ai.defineTool({
  name: 'getDeepPurposeAnalysis',
  description: 'Predicts the potential purpose or mechanism of action for a given molecule based on its SMILES string using an AI model (DeepPurpose). Use this after obtaining basic molecule info from PubChem to gain deeper insights into its function, especially if the query asks about potential use, mechanism, or targets.',
  inputSchema: z.object({
    smiles: z.string().describe('The SMILES string of the molecule to analyze with DeepPurpose.'),
  }),
  outputSchema: DeepPurposeResultSchema, // Use the exported schema
},
async input => {
  const analysis = await getDeepPurposeAnalysis(input.smiles);
  return analysis;
});


// Define the prompt - focus on generating the synthesized analysis text
const analysisPrompt = ai.definePrompt({
  name: 'analysisPrompt',
  tools: [pubChemTool, drugBankTool, deepPurposeTool],
  input: {
    schema: z.object({
      smiles: z.string().describe('The SMILES string of the drug candidate.'),
      targetProtein: z.string().optional().describe('The optional target protein for the analysis.'),
      query: z.string().describe('The analysis query from the user.'),
      // Include optional context from tool calls if needed, though flow can manage this
      pubChemName: z.string().optional().describe('IUPAC name from PubChem if found.'),
    }),
  },
  output: {
    // The prompt output focuses *only* on the synthesized text analysis
    schema: z.object({
      synthesizedAnalysis: z.string().describe('The comprehensive textual analysis of the drug candidate, synthesizing information from relevant tools used and addressing the user query.'),
    }),
  },
  prompt: `You are an expert pharmaceutical researcher specializing in early-stage drug discovery analysis.

  A user has submitted a drug candidate for analysis.
  SMILES String: {{{smiles}}}
  {{#if targetProtein}}Target Protein: {{{targetProtein}}}{{/if}}
  User Query: {{{query}}}

  Instructions:
  1.  **Foundation:** You have access to tools: 'getMoleculeBySmiles' (for basic chemical data), 'getDrugByName' (for known drug info), and 'getDeepPurposeAnalysis' (for functional prediction). Assume the essential 'getMoleculeBySmiles' has already been successfully called if an IUPAC name '{{pubChemName}}' is provided; otherwise, you *must* call it first. If it fails, report that limitation clearly.
  2.  **Tool Strategy:** Based on the user query "{{{query}}}" and the basic chemical data (especially the IUPAC name '{{pubChemName}}', if available), decide *if* you need to use 'getDrugByName' (e.g., if the name looks like a drug or the query asks about known drugs) and *if* you need 'getDeepPurposeAnalysis' (e.g., if the query asks about function, mechanism, or potential use).
  3.  **Synthesize:** Generate a comprehensive textual analysis that directly answers the user's query: "{{{query}}}".
      *   Integrate findings from the tools you decided to use. Clearly state the source (e.g., "PubChem indicates...", "DrugBank suggests...", "DeepPurpose predicts...").
      *   If a target protein ({{{targetProtein}}}) was provided, discuss the candidate's potential relevance to it, drawing connections from the available data (structure, properties, predicted purpose).
      *   If a tool fails or returns no relevant information, explicitly mention this limitation in your analysis (e.g., "DrugBank information for this name was not found," "DeepPurpose analysis did not yield a specific prediction."). Do not invent data.
  4.  **Focus:** Your primary output is the single 'synthesizedAnalysis' text block. Do not output raw tool data in this text. The calling function will handle gathering the raw tool outputs separately.

  Return ONLY the final, synthesized analysis text.
`,
});

// Define the main flow function
const analyzeDrugCandidateFlow = ai.defineFlow<
  typeof AnalyzeDrugCandidateInputSchema,
  typeof AnalyzeDrugCandidateOutputSchema
>({
  name: 'analyzeDrugCandidateFlow',
  inputSchema: AnalyzeDrugCandidateInputSchema,
  outputSchema: AnalyzeDrugCandidateOutputSchema,
}, async (input) => {
  console.log('Starting analyzeDrugCandidateFlow with input:', input);

  let pubChemData: Molecule | null = null;
  let drugBankData: Drug | null = null;
  let deepPurposeData: DeepPurposeResult | null = null;
  let synthesizedAnalysis = "Analysis could not be completed."; // Default analysis

  try {
    // Step 1: Always get PubChem data first (critical for context)
    // Note: We call the *service* directly here, not necessarily the tool via LLM,
    // because we *always* need this data for the next steps.
    // The tool is available *if* the LLM needs to re-fetch or verify.
    pubChemData = await getMoleculeBySmiles(input.smiles);

    if (!pubChemData) {
      // If PubChem fails, we cannot proceed meaningfully.
      // The component handles displaying this initial error better.
      // Here, we'll return a basic failure message in the structure.
      console.error(`analyzeDrugCandidateFlow: PubChem lookup failed for SMILES: ${input.smiles}. Aborting analysis.`);
      // Throw an error that the component can catch and display appropriately
      throw new Error(`Essential chemical data could not be retrieved from PubChem for SMILES: ${input.smiles}. Analysis cannot proceed.`);
      // return {
      //   synthesizedAnalysis: `Analysis failed: Essential chemical data could not be retrieved from PubChem for SMILES: ${input.smiles}.`,
      //   drugBankData: null,
      //   deepPurposeData: null,
      // };
    }

    // Step 2: Run the analysis prompt, providing PubChem name as context
    // The LLM will use tools as needed based on the prompt instructions.
    const llmInput = {
      ...input,
      smiles: pubChemData.canonicalSmiles, // Use canonical SMILES
      pubChemName: pubChemData.iupacName,
    };
    const { output: llmOutput, history } = await analysisPrompt.withTracking(llmInput);

     if (!llmOutput?.synthesizedAnalysis) {
        console.error('analyzeDrugCandidateFlow: Analysis prompt returned no synthesized analysis.');
        throw new Error('Analysis failed: The AI model did not generate an analysis text.');
     }
     synthesizedAnalysis = llmOutput.synthesizedAnalysis;
     console.log('analyzeDrugCandidateFlow: Received synthesized analysis:', synthesizedAnalysis);

    // Step 3: Extract structured data from the LLM's tool calls in history
    if (history) {
      for (const event of history) {
        if (event.type === 'toolRequest' && event.toolRequest.toolResponse?.output) {
          const toolName = event.toolRequest.name;
          const toolOutput = event.toolRequest.toolResponse.output;

          if (toolName === 'getDrugByName' && toolOutput) {
            try {
              // Validate the output against the schema
              drugBankData = DrugSchema.parse(toolOutput);
              console.log('analyzeDrugCandidateFlow: Extracted DrugBank data:', drugBankData);
            } catch (validationError) {
              console.warn(`analyzeDrugCandidateFlow: Failed to validate DrugBank tool output:`, validationError);
              // Keep drugBankData as null if validation fails
            }
          } else if (toolName === 'getDeepPurposeAnalysis' && toolOutput) {
             try {
                // Validate the output against the schema
                deepPurposeData = DeepPurposeResultSchema.parse(toolOutput);
                console.log('analyzeDrugCandidateFlow: Extracted DeepPurpose data:', deepPurposeData);
             } catch (validationError) {
               console.warn(`analyzeDrugCandidateFlow: Failed to validate DeepPurpose tool output:`, validationError);
                // Keep deepPurposeData as null if validation fails
             }
          }
          // We don't need to extract PubChem data here as we fetched it directly earlier.
        }
      }
    } else {
        console.warn("analyzeDrugCandidateFlow: No history found for tool call extraction.");
    }

    // Return the combined structured output
    return {
      synthesizedAnalysis,
      drugBankData,
      deepPurposeData,
      // pubChemData: pubChemData // We now fetch this in the component
    };

  } catch (error) {
    console.error('Error during analyzeDrugCandidateFlow execution:', error);
    // Re-throw the error to be caught by the calling component
    throw error;
  }
});

// Export the wrapper function
export async function analyzeDrugCandidate(input: AnalyzeDrugCandidateInput): Promise<AnalyzeDrugCandidateOutput> {
  return analyzeDrugCandidateFlow(input);
}
