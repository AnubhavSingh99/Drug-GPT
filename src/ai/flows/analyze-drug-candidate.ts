
// This file is generated by Firebase Genkit.
'use server';
/**
 * @fileOverview An AI agent for analyzing drug candidates.
 *
 * - analyzeDrugCandidate - A function that handles the drug candidate analysis process.
 * - AnalyzeDrugCandidateInput - The input type for the analyzeDrugCandidate function.
 * - AnalyzeDrugCandidateOutput - The return type for the analyzeDrugCandidate function.
 */

import { ai } from '@/ai/ai-instance';
import { z } from 'genkit';
import { getMoleculeBySmiles, type Molecule } from '@/services/pubchem';
// Remove direct import from chembl service
// import { type Drug, DrugSchema } from '@/services/chembl'; // REMOVED
import { getDeepPurposeAnalysis } from '@/services/deeppurpose'; // Service function import remains

// Define input schema
const AnalyzeDrugCandidateInputSchema = z.object({
  smiles: z
    .string()
    .describe('The SMILES string of the drug candidate.'),
  targetProtein: z
    .string()
    .optional()
    .describe('The optional target protein for the analysis.'),
  query: z.string().describe('The analysis query from the user.'),
});
export type AnalyzeDrugCandidateInput = z.infer<typeof AnalyzeDrugCandidateInputSchema>;

// Define DeepPurpose schema and type locally within this flow file
const DeepPurposeResultSchema = z.object({
  predictedPurpose: z.string().describe('The predicted purpose or mechanism of action analysis.'),
  confidence: z.number().optional().describe('Confidence score (0-1) for the prediction, if available.'),
});
type DeepPurposeResult = z.infer<typeof DeepPurposeResultSchema>;


// Define the ChEMBL Drug schema locally, as we no longer import it from the service
const DrugSchema = z.object({
    chemblId: z.string().describe('The ChEMBL ID.'),
    name: z.string().describe('The compound name.'),
    maxPhase: z.number().nullable().optional().describe('The maximum phase a drug has reached in clinical trials (0-4).'),
    molecularWeight: z.number().optional().describe('The molecular weight.'),
    molecularFormula: z.string().optional().describe('The molecular formula.'),
    description: z.string().optional().describe('Drug description, which could contain indications or therapeutic flags.'),
});
type Drug = z.infer<typeof DrugSchema>;


// Define the structured output schema
const AnalyzeDrugCandidateOutputSchema = z.object({
  synthesizedAnalysis: z.string().describe('The overall synthesized analysis addressing the user query, incorporating information from all relevant tools used.'),
  // Use the locally defined DrugSchema
  chemblData: z.nullable(DrugSchema).describe('Information retrieved from ChEMBL (via Firebase API), if applicable.'),
  deepPurposeData: z.nullable(DeepPurposeResultSchema).describe('Prediction results from the DeepPurpose analysis.'),
});
export type AnalyzeDrugCandidateOutput = z.infer<typeof AnalyzeDrugCandidateOutputSchema>;


// Define tools
const pubChemTool = ai.defineTool({
  name: 'getMoleculeBySmiles',
  description: 'Retrieves basic molecule information (CID, formula, IUPAC name, canonical SMILES, molecular weight) from PubChem based on a SMILES string. Should be the first step for chemical data gathering.',
  inputSchema: z.object({
    smiles: z.string().describe('The SMILES string of the molecule to search for.'),
  }),
  outputSchema: z.object({
    cid: z.number().describe('The PubChem CID (Compound Identifier).'),
    molecularFormula: z.string().describe('The molecular formula.'),
    iupacName: z.string().optional().describe('The IUPAC name, if available.'),
    canonicalSmiles: z.string().describe('The canonical SMILES string.'),
    molecularWeight: z.number().describe('The molecular weight.'),
  }),
},
async input => {
  console.log(`PubChem Tool called with SMILES: ${input.smiles}`);
  const molecule = await getMoleculeBySmiles(input.smiles);
  if (!molecule) {
    console.error(`PubChem tool failed to retrieve molecule for SMILES: ${input.smiles}`);
    throw new Error(`PubChem tool execution failed: Could not retrieve molecule for SMILES: ${input.smiles}`);
  }
  console.log(`PubChem Tool successfully returned data for SMILES: ${input.smiles}`);
  return {
    cid: molecule.cid,
    molecularFormula: molecule.molecularFormula,
    iupacName: molecule.iupacName,
    canonicalSmiles: molecule.canonicalSmiles,
    molecularWeight: molecule.molecularWeight,
  };
});

// Updated tool for ChEMBL - now calls the internal API route
const chemblTool = ai.defineTool({
  name: 'getDrugByNameFromDatabase', // Renamed tool slightly for clarity
  description: 'Retrieves known drug/compound information from our internal database (via API) based on a name. Use this tool if the molecule identified by PubChem has an IUPAC name that suggests it might be a known compound/drug, or if the user\'s query explicitly mentions a drug name.',
  inputSchema: z.object({
    drugName: z.string().describe('The name of the drug/compound to search for in the database.'),
  }),
  outputSchema: z.nullable(DrugSchema), // Use the locally defined ChEMBL Drug schema
},
async input => {
  console.log(`Database Tool called with Name: ${input.drugName}`);
  try {
      // Construct the full URL to the API route
      // Assumes the app is running on localhost:9002 during development
      // In production, this needs to be the actual deployed URL
      const apiUrl = process.env.NODE_ENV === 'production'
         ? `${process.env.NEXT_PUBLIC_APP_URL}/api/data` // Use an env var for the deployed URL
         : `http://localhost:9002/api/data`; // Adjust port if needed

      console.log(`Calling API: ${apiUrl}?drugName=${encodeURIComponent(input.drugName)}`);
      const response = await fetch(`${apiUrl}?drugName=${encodeURIComponent(input.drugName)}`);

      if (!response.ok) {
        // Handle non-2xx responses (like 404 Not Found)
        if (response.status === 404) {
           console.log(`Database tool: API returned 404, drug "${input.drugName}" not found.`);
           return null; // Return null if not found
        }
        console.error(`Database tool: API request failed with status ${response.status} for drug: ${input.drugName}`);
        throw new Error(`API request failed with status ${response.status}`); // Throw error for other failures
      }

      const drugData = await response.json();

      // The API route now returns the drug object directly or an error/message
      if (!drugData || drugData.error || drugData.message) {
         console.log(`Database tool: API did not return valid data for drug: ${input.drugName}. Response:`, drugData);
         return null; // Return null if API indicates error or no data
      }

      // Validate the received data against the local DrugSchema
      const validatedDrug = DrugSchema.parse(drugData);
      console.log(`Database Tool successfully returned validated data for name: ${input.drugName}`);
      return validatedDrug;

  } catch (error: any) {
       console.error(`Database tool execution failed for drug "${input.drugName}":`, error);
       // Don't throw here, allow the flow to report it as a null result
       // throw new Error(`Database tool execution failed: ${error.message}`);
       return null; // Return null on any error during API call or parsing
  }
});

const deepPurposeTool = ai.defineTool({
  name: 'getDeepPurposeAnalysis',
  description: 'Predicts the potential purpose or mechanism of action for a given molecule based on its SMILES string using an AI model (DeepPurpose). Use this after obtaining basic molecule info from PubChem to gain deeper insights into its function, especially if the query asks about potential use, mechanism, or targets.',
  inputSchema: z.object({
    smiles: z.string().describe('The SMILES string of the molecule to analyze with DeepPurpose.'),
  }),
  outputSchema: z.nullable(DeepPurposeResultSchema), // Use local schema, allow null
},
async input => {
  console.log(`DeepPurpose Tool called with SMILES: ${input.smiles}`);
  const analysis = await getDeepPurposeAnalysis(input.smiles);
   if (!analysis) {
     console.log(`DeepPurpose tool did not generate prediction for SMILES: ${input.smiles}. Returning null.`);
     return null;
   }
    try {
        const validatedAnalysis = DeepPurposeResultSchema.parse(analysis);
        console.log(`DeepPurpose Tool successfully returned validated prediction for SMILES: ${input.smiles}`);
        return validatedAnalysis;
    } catch (validationError) {
        console.error(`DeepPurpose tool returned data failed validation for SMILES ${input.smiles}:`, validationError, "Raw data:", analysis);
        return null;
    }
});


// Define the prompt - focus on generating the synthesized analysis text
const analysisPrompt = ai.definePrompt({
  name: 'analysisPrompt',
  // Updated tool name in the list
  tools: [pubChemTool, chemblTool, deepPurposeTool],
  input: {
    schema: z.object({
      smiles: z.string().describe('The SMILES string of the drug candidate.'),
      targetProtein: z.string().optional().describe('The optional target protein for the analysis.'),
      query: z.string().describe('The analysis query from the user.'),
      pubChemName: z.string().optional().describe('IUPAC name from PubChem if found.'),
    }),
  },
  output: {
    schema: z.object({
      synthesizedAnalysis: z.string().describe('The comprehensive textual analysis of the drug candidate, synthesizing information from relevant tools used and addressing the user query.'),
    }),
  },
  // Updated prompt text to refer to 'Database' or 'ChEMBL Database' instead of just 'ChEMBL'
  prompt: `You are an expert pharmaceutical researcher specializing in early-stage drug discovery analysis.

  A user has submitted a drug candidate for analysis.
  SMILES String: {{{smiles}}}
  {{#if targetProtein}}Target Protein: {{{targetProtein}}}{{/if}}
  User Query: {{{query}}}

  Instructions:
  1.  **Foundation:** You have access to tools: 'getMoleculeBySmiles' (for basic chemical data from PubChem), 'getDrugByNameFromDatabase' (for known compound info from our internal ChEMBL database), and 'getDeepPurposeAnalysis' (for functional prediction). Assume the essential 'getMoleculeBySmiles' has already been successfully called if an IUPAC name '{{pubChemName}}' is provided; otherwise, you *must* call it first. If it fails, report that limitation clearly.
  2.  **Tool Strategy:** Based on the user query "{{{query}}}" and the basic chemical data (especially the IUPAC name '{{pubChemName}}', if available), decide *if* you need to use 'getDrugByNameFromDatabase' (e.g., if the name looks like a known compound or the query asks about known drugs/compounds) and *if* you need 'getDeepPurposeAnalysis' (e.g., if the query asks about function, mechanism, or potential use). Use the tools *only* if relevant to the query.
  3.  **Synthesize:** Generate a comprehensive textual analysis that directly answers the user's query: "{{{query}}}".
      *   Integrate findings *only* from the tools you decided to use and that returned data successfully. Clearly state the source (e.g., "PubChem indicates...", "Our ChEMBL database suggests...", "DeepPurpose predicts...").
      *   If a tool returns no data (e.g., 'getDrugByNameFromDatabase' finds no matching compound or returns null), explicitly state that in your analysis (e.g., "No information was found in our ChEMBL database for this compound name."). Do not invent data.
      *   If a target protein ({{{targetProtein}}}) was provided, discuss the candidate's potential relevance to it, drawing connections from the available data (structure, properties, predicted purpose).
      *   If a tool fails due to an error during its execution (which will be reported back to you), explicitly mention this limitation in your analysis (e.g., "The PubChem tool failed to retrieve data." or "The database lookup tool failed.").
  4.  **Focus:** Your primary output is the single 'synthesizedAnalysis' text block. Do not output raw tool data in this text. The calling function will handle gathering the raw tool outputs separately.

  Return ONLY the final, synthesized analysis text.
`,
});

// Define the main flow function
const analyzeDrugCandidateFlow = ai.defineFlow<
  typeof AnalyzeDrugCandidateInputSchema,
  typeof AnalyzeDrugCandidateOutputSchema
>({
  name: 'analyzeDrugCandidateFlow',
  inputSchema: AnalyzeDrugCandidateInputSchema,
  outputSchema: AnalyzeDrugCandidateOutputSchema,
}, async (input) => {
  console.log('Starting analyzeDrugCandidateFlow with input:', JSON.stringify(input));

  let pubChemData: Molecule | null = null;
  let chemblData: Drug | null = null; // Variable holds parsed ChEMBL data
  let deepPurposeData: DeepPurposeResult | null = null;
  let synthesizedAnalysis = "Analysis could not be completed.";

  try {
    console.log(`Step 1: Fetching PubChem data for SMILES: ${input.smiles}`);
    pubChemData = await getMoleculeBySmiles(input.smiles);

    if (!pubChemData) {
      console.error(`analyzeDrugCandidateFlow: PubChem lookup failed for SMILES: ${input.smiles}. Aborting analysis.`);
      throw new Error(`Essential chemical data could not be retrieved from PubChem for SMILES: ${input.smiles}. Analysis cannot proceed.`);
    }
    console.log('Step 1: PubChem data fetched successfully:', JSON.stringify(pubChemData));

    const llmInput = {
      ...input,
      smiles: pubChemData.canonicalSmiles,
      pubChemName: pubChemData.iupacName,
    };
    console.log('Step 2: Calling analysisPrompt with LLM input:', JSON.stringify(llmInput));

    const promptResult = await analysisPrompt(llmInput);
    const llmOutput = promptResult.output;
    const history = promptResult.history;

    console.log('Step 2: analysisPrompt response received.');
    console.log('Prompt History:', JSON.stringify(history, null, 2));


     if (!llmOutput?.synthesizedAnalysis) {
        console.error('analyzeDrugCandidateFlow: Analysis prompt returned no synthesized analysis.');
        throw new Error('Analysis failed: The AI model did not generate an analysis text.');
     }
     synthesizedAnalysis = llmOutput.synthesizedAnalysis;
     console.log('Step 2: Received synthesized analysis:', synthesizedAnalysis);

    console.log("Step 3: Extracting structured data from history...");
    if (history) {
      for (const event of history) {
        if (event.type === 'toolRequest' && event.toolRequest.toolResponse && event.toolRequest.toolResponse.output) {
          const toolName = event.toolRequest.name;
          const toolOutput = event.toolRequest.toolResponse.output;
          console.log(`Found successful tool response for '${toolName}':`, JSON.stringify(toolOutput));

           if (toolOutput != null) {
               // Updated tool name check
               if (toolName === 'getDrugByNameFromDatabase') {
                 try {
                   chemblData = DrugSchema.parse(toolOutput);
                   console.log('analyzeDrugCandidateFlow: Successfully parsed ChEMBL (Database) data:', JSON.stringify(chemblData));
                 } catch (validationError) {
                   console.warn(`analyzeDrugCandidateFlow: Failed to validate Database tool output. Error:`, validationError, 'Raw Output:', toolOutput);
                   chemblData = null;
                 }
               } else if (toolName === 'getDeepPurposeAnalysis') {
                 try {
                   deepPurposeData = DeepPurposeResultSchema.parse(toolOutput);
                   console.log('analyzeDrugCandidateFlow: Successfully parsed DeepPurpose data:', JSON.stringify(deepPurposeData));
                 } catch (validationError) {
                   console.warn(`analyzeDrugCandidateFlow: Failed to validate DeepPurpose tool output. Error:`, validationError, 'Raw Output:', toolOutput);
                   deepPurposeData = null;
                 }
               }
           } else {
              console.log(`Tool '${toolName}' returned null or undefined output, skipping parsing.`);
               // Updated tool name check
               if (toolName === 'getDrugByNameFromDatabase') chemblData = null;
               if (toolName === 'getDeepPurposeAnalysis') deepPurposeData = null;
           }
        } else if (event.type === 'toolRequest' && event.toolRequest.toolResponse?.error) {
            console.warn(`analyzeDrugCandidateFlow: Tool '${event.toolRequest.name}' execution failed with error:`, event.toolRequest.toolResponse.error);
        } else if (event.type === 'toolRequest' && !event.toolRequest.toolResponse) {
             console.warn(`analyzeDrugCandidateFlow: Tool request for '${event.toolRequest.name}' found in history, but no response recorded.`);
        }
      }
    } else {
        console.warn("analyzeDrugCandidateFlow: No history found for tool call extraction.");
    }
    console.log("Step 3: Finished extracting structured data. ChEMBL (Database):", JSON.stringify(chemblData), "DeepPurpose:", JSON.stringify(deepPurposeData));

    const finalOutput = {
      synthesizedAnalysis,
      chemblData,
      deepPurposeData,
    };
    console.log("analyzeDrugCandidateFlow: Returning final output:", JSON.stringify(finalOutput));
    return finalOutput;

  } catch (error: any) {
    console.error('Error during analyzeDrugCandidateFlow execution:', error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(errorMessage);
  }
});

export async function analyzeDrugCandidate(input: AnalyzeDrugCandidateInput): Promise<AnalyzeDrugCandidateOutput> {
  console.log('Calling analyzeDrugCandidate wrapper with input:', JSON.stringify(input));
  try {
    const result = await analyzeDrugCandidateFlow(input);
    console.log('analyzeDrugCandidate wrapper received result:', JSON.stringify(result));
    return result;
  } catch (error) {
     console.error('analyzeDrugCandidate wrapper caught error:', error);
     throw error;
  }
}
