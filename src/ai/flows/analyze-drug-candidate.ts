
// This file is generated by Firebase Genkit.
'use server';
/**
 * @fileOverview An AI agent for analyzing drug candidates.
 *
 * - analyzeDrugCandidate - A function that handles the drug candidate analysis process.
 * - AnalyzeDrugCandidateInput - The input type for the analyzeDrugCandidate function.
 * - AnalyzeDrugCandidateOutput - The return type for the analyzeDrugCandidate function.
 */

import { ai } from '@/ai/ai-instance';
import { z } from 'genkit';
import { getMoleculeBySmiles, type Molecule } from '@/services/pubchem';
// Remove DrugBank/ChEMBL specific imports
import { getDeepPurposeAnalysis } from '@/services/deeppurpose'; // Service function import remains

// Define input schema
const AnalyzeDrugCandidateInputSchema = z.object({
  smiles: z
    .string()
    .describe('The SMILES string of the drug candidate.'),
  targetProtein: z
    .string()
    .optional()
    .describe('The optional target protein for the analysis.'),
  query: z.string().describe('The analysis query from the user.'),
});
export type AnalyzeDrugCandidateInput = z.infer<typeof AnalyzeDrugCandidateInputSchema>;

// Define DeepPurpose schema and type locally within this flow file
const DeepPurposeResultSchema = z.object({
  predictedPurpose: z.string().describe('The predicted purpose or mechanism of action analysis.'),
  confidence: z.number().optional().describe('Confidence score (0-1) for the prediction, if available.'),
});
type DeepPurposeResult = z.infer<typeof DeepPurposeResultSchema>;

// Define the structured output schema - REMOVED chemblData
const AnalyzeDrugCandidateOutputSchema = z.object({
  synthesizedAnalysis: z.string().describe('The overall synthesized analysis addressing the user query, incorporating information from PubChem, DeepPurpose (if used), and the LLM\'s internal knowledge.'),
  // Removed chemblData: z.nullable(DrugSchema).describe(...)
  pubChemData: z.nullable(z.object({ // Add PubChem data directly to output
      cid: z.number().describe('The PubChem CID (Compound Identifier).'),
      molecularFormula: z.string().describe('The molecular formula.'),
      iupacName: z.string().optional().describe('The IUPAC name, if available.'),
      canonicalSmiles: z.string().describe('The canonical SMILES string.'),
      molecularWeight: z.number().describe('The molecular weight.'),
  })).describe('Basic molecule information retrieved from PubChem.'),
  deepPurposeData: z.nullable(DeepPurposeResultSchema).describe('Prediction results from the DeepPurpose analysis, if applicable.'),
});
export type AnalyzeDrugCandidateOutput = z.infer<typeof AnalyzeDrugCandidateOutputSchema>;


// Define tools
const pubChemTool = ai.defineTool({
  name: 'getMoleculeBySmiles',
  description: 'Retrieves basic molecule information (CID, formula, IUPAC name, canonical SMILES, molecular weight) from PubChem based on a SMILES string. Should be the first step for chemical data gathering.',
  inputSchema: z.object({
    smiles: z.string().describe('The SMILES string of the molecule to search for.'),
  }),
  outputSchema: z.object({
    cid: z.number().describe('The PubChem CID (Compound Identifier).'),
    molecularFormula: z.string().describe('The molecular formula.'),
    iupacName: z.string().optional().describe('The IUPAC name, if available.'),
    canonicalSmiles: z.string().describe('The canonical SMILES string.'),
    molecularWeight: z.number().describe('The molecular weight.'),
  }),
},
async input => {
  console.log(`PubChem Tool called with SMILES: ${input.smiles}`);
  const molecule = await getMoleculeBySmiles(input.smiles);
  if (!molecule) {
    console.error(`PubChem tool failed to retrieve molecule for SMILES: ${input.smiles}`);
    // Throwing error here ensures the flow knows this essential step failed
    throw new Error(`PubChem tool execution failed: Could not retrieve molecule for SMILES: ${input.smiles}`);
  }
  console.log(`PubChem Tool successfully returned data for SMILES: ${input.smiles}`);
  // Return the full Molecule structure matching the output schema
  return {
    cid: molecule.cid,
    molecularFormula: molecule.molecularFormula,
    iupacName: molecule.iupacName,
    canonicalSmiles: molecule.canonicalSmiles,
    molecularWeight: molecule.molecularWeight,
  };
});

// REMOVED chemblTool definition

const deepPurposeTool = ai.defineTool({
  name: 'getDeepPurposeAnalysis',
  description: 'Predicts the potential purpose or mechanism of action for a given molecule based on its SMILES string using an AI model (DeepPurpose). Use this after obtaining basic molecule info from PubChem to gain deeper insights into its function, especially if the query asks about potential use, mechanism, or targets.',
  inputSchema: z.object({
    smiles: z.string().describe('The SMILES string of the molecule to analyze with DeepPurpose.'),
  }),
  outputSchema: z.nullable(DeepPurposeResultSchema), // Use local schema, allow null
},
async input => {
  console.log(`DeepPurpose Tool called with SMILES: ${input.smiles}`);
  const analysis = await getDeepPurposeAnalysis(input.smiles);
   if (!analysis) {
     console.log(`DeepPurpose tool did not generate prediction for SMILES: ${input.smiles}. Returning null.`);
     return null;
   }
    try {
        // Ensure the analysis object matches the expected structure before parsing
        if (typeof analysis.predictedPurpose !== 'string') {
             console.warn(`DeepPurpose service for SMILES ${input.smiles} returned invalid structure. Missing predictedPurpose. Raw:`, analysis);
             return null;
        }
        const validatedAnalysis = DeepPurposeResultSchema.parse(analysis);
        console.log(`DeepPurpose Tool successfully returned validated prediction for SMILES: ${input.smiles}`);
        return validatedAnalysis;
    } catch (validationError) {
        console.error(`DeepPurpose tool returned data failed validation for SMILES ${input.smiles}:`, validationError, "Raw data:", analysis);
        return null;
    }
});


// Define the prompt - focus on generating the synthesized analysis text
const analysisPrompt = ai.definePrompt({
  name: 'analysisPrompt',
  // Removed chemblTool from the list
  tools: [pubChemTool, deepPurposeTool],
  input: {
    schema: z.object({
      smiles: z.string().describe('The canonical SMILES string of the drug candidate (from PubChem).'),
      targetProtein: z.string().optional().describe('The optional target protein for the analysis.'),
      query: z.string().describe('The analysis query from the user.'),
      // Pass PubChem data explicitly for the LLM to use
      pubChemData: z.object({
          cid: z.number().describe('The PubChem CID (Compound Identifier).'),
          molecularFormula: z.string().describe('The molecular formula.'),
          iupacName: z.string().optional().describe('The IUPAC name, if available.'),
          canonicalSmiles: z.string().describe('The canonical SMILES string.'),
          molecularWeight: z.number().describe('The molecular weight.'),
      }).describe('Basic molecule information from PubChem.'),
    }),
  },
  output: {
    schema: z.object({
      synthesizedAnalysis: z.string().describe('The comprehensive textual analysis of the drug candidate, synthesizing information from PubChem, DeepPurpose (if used), and internal knowledge, directly addressing the user query.'),
    }),
  },
  // Updated prompt instructions
  prompt: `You are an expert pharmaceutical researcher specializing in early-stage drug discovery analysis.

  A user has submitted a drug candidate for analysis.
  Canonical SMILES String: {{{smiles}}}
  {{#if targetProtein}}Target Protein: {{{targetProtein}}}{{/if}}
  User Query: {{{query}}}

  Available Data:
  - PubChem Data: You have been provided with basic chemical information (CID: {{pubChemData.cid}}, Formula: {{pubChemData.molecularFormula}}, IUPAC Name: {{#if pubChemData.iupacName}}{{pubChemData.iupacName}}{{else}}N/A{{/if}}, Mol Weight: {{pubChemData.molecularWeight}}).

  Available Tools:
  - 'getDeepPurposeAnalysis': Predicts potential function/mechanism based on SMILES.

  Instructions:
  1.  **Analyze PubChem Data & Internal Knowledge:** Review the provided PubChem data (especially the IUPAC name, if available) and the SMILES structure. Access your internal knowledge base about chemical compounds and drugs. Determine if this molecule is a known compound/drug. Include relevant information you know about it (e.g., common uses, indications, mechanism of action, known maximum clinical trial phase) in your analysis. If it's not a known compound or you lack specific information, state that clearly.
  2.  **Tool Strategy:** Based *only* on the user query "{{{query}}}", decide *if* you need to use the 'getDeepPurposeAnalysis' tool. For example, use it if the query asks about function, mechanism, potential use, or targets. Do NOT use tools unnecessarily.
  3.  **Synthesize:** Generate a comprehensive textual analysis that directly answers the user's query: "{{{query}}}".
      *   Integrate findings from PubChem data, your internal knowledge, and the DeepPurpose tool *only if you used it and it returned data*. Clearly state the source of information (e.g., "PubChem data indicates...", "Based on its structure and known compounds...", "DeepPurpose predicts...").
      *   If DeepPurpose returns no prediction or null, explicitly state that (e.g., "DeepPurpose analysis did not yield a prediction."). Do not invent data.
      *   If a target protein ({{{targetProtein}}}) was provided, discuss the candidate's potential relevance to it, drawing connections from the available data (structure, properties, predicted purpose, known information).
      *   If a tool fails due to an error during execution (which will be reported back to you), explicitly mention this limitation (e.g., "The DeepPurpose tool failed execution.").
  4.  **Focus:** Your primary output is the single 'synthesizedAnalysis' text block. Do not output raw tool data here. The calling function handles gathering raw tool outputs.

  Return ONLY the final, synthesized analysis text.
`,
});

// Define the main flow function
const analyzeDrugCandidateFlow = ai.defineFlow<
  typeof AnalyzeDrugCandidateInputSchema,
  typeof AnalyzeDrugCandidateOutputSchema
>({
  name: 'analyzeDrugCandidateFlow',
  inputSchema: AnalyzeDrugCandidateInputSchema,
  outputSchema: AnalyzeDrugCandidateOutputSchema,
}, async (input) => {
  console.log('Starting analyzeDrugCandidateFlow with input:', JSON.stringify(input));

  let pubChemDataResult: Molecule | null = null;
  // Removed chemblData variable
  let deepPurposeDataResult: DeepPurposeResult | null = null;
  let synthesizedAnalysis = "Analysis could not be completed.";

  try {
    // Step 1: Fetch PubChem data using the TOOL. This ensures it's trackable and handles errors robustly.
    console.log(`Step 1: Calling PubChem tool for SMILES: ${input.smiles}`);
    // Use the tool definition directly
    // Note: The tool itself throws an error if it fails, which will be caught by the main try/catch.
    const pubChemToolResult = await pubChemTool({ smiles: input.smiles });
    pubChemDataResult = pubChemToolResult; // Assign the successful result
    console.log('Step 1: PubChem tool executed successfully:', JSON.stringify(pubChemDataResult));


    // Prepare input for the main analysis prompt, including the fetched PubChem data
    const llmInput = {
      smiles: pubChemDataResult.canonicalSmiles, // Use canonical SMILES from PubChem
      targetProtein: input.targetProtein,
      query: input.query,
      pubChemData: pubChemDataResult, // Pass the full PubChem result object
    };
    console.log('Step 2: Calling analysisPrompt with LLM input:', JSON.stringify(llmInput));

    // Call the main analysis prompt
    const promptResult = await analysisPrompt(llmInput);
    const llmOutput = promptResult.output;
    const history = promptResult.history; // Get history for tool calls

    console.log('Step 2: analysisPrompt response received.');
    console.log('Prompt History:', JSON.stringify(history, null, 2)); // Log history for debugging

    // Check if the LLM provided the synthesized analysis
     if (!llmOutput?.synthesizedAnalysis) {
        console.error('analyzeDrugCandidateFlow: Analysis prompt returned no synthesized analysis.');
        // Provide a more informative error message back to the user
        throw new Error('Analysis failed: The AI model did not generate the required analysis text.');
     }
     synthesizedAnalysis = llmOutput.synthesizedAnalysis;
     console.log('Step 2: Received synthesized analysis:', synthesizedAnalysis);

    // Step 3: Extract structured data (DeepPurpose result) from the history if the tool was called
    console.log("Step 3: Extracting structured data from history...");
    if (history) {
      for (const event of history) {
        // Check if it's a request for the DeepPurpose tool that completed successfully
        if (event.type === 'toolRequest' && event.toolRequest.name === 'getDeepPurposeAnalysis' && event.toolRequest.toolResponse && event.toolRequest.toolResponse.output) {
            const toolOutput = event.toolRequest.toolResponse.output;
            console.log(`Found successful tool response for 'getDeepPurposeAnalysis':`, JSON.stringify(toolOutput));
            if (toolOutput != null) {
                try {
                    // Validate the structure before assigning
                    deepPurposeDataResult = DeepPurposeResultSchema.parse(toolOutput);
                    console.log('analyzeDrugCandidateFlow: Successfully parsed DeepPurpose data:', JSON.stringify(deepPurposeDataResult));
                } catch (validationError) {
                    console.warn(`analyzeDrugCandidateFlow: Failed to validate DeepPurpose tool output. Error:`, validationError, 'Raw Output:', toolOutput);
                    deepPurposeDataResult = null; // Set to null if validation fails
                }
            } else {
                console.log(`Tool 'getDeepPurposeAnalysis' returned null or undefined output.`);
                deepPurposeDataResult = null;
            }
            break; // Assume only one call to DeepPurpose per flow run
        } else if (event.type === 'toolRequest' && event.toolRequest.name === 'getDeepPurposeAnalysis' && event.toolRequest.toolResponse?.error) {
           // Log if the tool execution itself failed
           console.warn(`analyzeDrugCandidateFlow: Tool 'getDeepPurposeAnalysis' execution failed with error:`, event.toolRequest.toolResponse.error);
            deepPurposeDataResult = null; // Ensure it's null if the tool errored
            break;
        } else if (event.type === 'toolRequest' && event.toolRequest.name === 'getDeepPurposeAnalysis' && !event.toolRequest.toolResponse) {
            // Log if the tool was requested but no response was recorded (should be rare)
            console.warn(`analyzeDrugCandidateFlow: Tool request for 'getDeepPurposeAnalysis' found in history, but no response recorded.`);
             deepPurposeDataResult = null;
            break;
        }
      }
    } else {
        console.warn("analyzeDrugCandidateFlow: No history found for tool call extraction.");
    }
     console.log("Step 3: Finished extracting structured data. DeepPurpose:", JSON.stringify(deepPurposeDataResult));

    // Construct the final output, including PubChem data
    const finalOutput: AnalyzeDrugCandidateOutput = {
      synthesizedAnalysis,
      pubChemData: pubChemDataResult, // Include the fetched PubChem data
      deepPurposeData: deepPurposeDataResult, // Include DeepPurpose data (null if not used/failed)
    };
    console.log("analyzeDrugCandidateFlow: Returning final output:", JSON.stringify(finalOutput));
    return finalOutput;

  } catch (error: any) {
    // Catch errors from PubChem tool or analysis prompt
    console.error('Error during analyzeDrugCandidateFlow execution:', error);
    // Re-throw the error to be handled by the calling function/component
    // The error message should be reasonably informative (e.g., from PubChem tool failure or LLM failure)
    const errorMessage = error instanceof Error ? error.message : String(error);
    // throw error; // Re-throw the original error object
     throw new Error(`Analysis Flow Error: ${errorMessage}`); // Wrap for potentially better context
  }
});

// Exported wrapper function remains the same
export async function analyzeDrugCandidate(input: AnalyzeDrugCandidateInput): Promise<AnalyzeDrugCandidateOutput> {
  console.log('Calling analyzeDrugCandidate wrapper with input:', JSON.stringify(input));
  try {
    const result = await analyzeDrugCandidateFlow(input);
    console.log('analyzeDrugCandidate wrapper received result:', JSON.stringify(result));
    return result;
  } catch (error) {
     console.error('analyzeDrugCandidate wrapper caught error:', error);
     // Re-throw the error to be caught by the UI component
     throw error;
  }
}
