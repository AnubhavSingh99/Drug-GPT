// This file is generated by Firebase Genkit.
'use server';
/**
 * @fileOverview An AI agent for analyzing drug candidates.
 *
 * - analyzeDrugCandidate - A function that handles the drug candidate analysis process.
 * - AnalyzeDrugCandidateInput - The input type for the analyzeDrugCandidate function.
 * - AnalyzeDrugCandidateOutput - The return type for the analyzeDrugCandidate function.
 */

import {ai} from '@/ai/ai-instance';
import {z} from 'genkit';
import {getMoleculeBySmiles} from '@/services/pubchem';
import {getDrugByName} from '@/services/drugbank';

const AnalyzeDrugCandidateInputSchema = z.object({
  smiles: z
    .string()
    .describe('The SMILES string of the drug candidate.'),
  targetProtein: z
    .string()
    .optional()
    .describe('The optional target protein for the analysis.'),
  query: z.string().describe('The analysis query from the user.'),
});
export type AnalyzeDrugCandidateInput = z.infer<typeof AnalyzeDrugCandidateInputSchema>;

const AnalyzeDrugCandidateOutputSchema = z.object({
  analysis: z.string().describe('The analysis of the drug candidate.'),
});
export type AnalyzeDrugCandidateOutput = z.infer<typeof AnalyzeDrugCandidateOutputSchema>;

export async function analyzeDrugCandidate(input: AnalyzeDrugCandidateInput): Promise<AnalyzeDrugCandidateOutput> {
  return analyzeDrugCandidateFlow(input);
}

const pubChemTool = ai.defineTool({
  name: 'getMoleculeBySmiles',
  description: 'Retrieves molecule information from PubChem based on a SMILES string.',
  inputSchema: z.object({
    smiles: z.string().describe('The SMILES string of the molecule to search for.'),
  }),
  outputSchema: z.object({
    cid: z.number().describe('The PubChem CID (Compound Identifier).'),
    molecularFormula: z.string().describe('The molecular formula.'),
    iupacName: z.string().optional().describe('The IUPAC name, if available.'),
    canonicalSmiles: z.string().describe('The canonical SMILES string.'),
    molecularWeight: z.number().describe('The molecular weight.'),
  }),
},
async input => {
  const molecule = await getMoleculeBySmiles(input.smiles);
  if (!molecule) {
    throw new Error(`Molecule with SMILES ${input.smiles} not found in PubChem.`);
  }
  return molecule;
}
);

const drugBankTool = ai.defineTool({
  name: 'getDrugByName',
  description: 'Retrieves drug information from DrugBank based on the drug name. Useful if the SMILES string corresponds to a known drug or if the user mentions a specific drug.',
  inputSchema: z.object({
    drugName: z.string().describe('The name of the drug to search for.'),
  }),
  outputSchema: z.object({
    drugbankId: z.string().describe('The DrugBank ID.'),
    name: z.string().describe('The generic name of the drug.'),
    description: z.string().optional().describe('A brief description or indication of the drug\'s use.'),
    molecularFormula: z.string().optional().describe('The molecular formula.'),
    averageMolecularWeight: z.number().optional().describe('The average molecular weight.'),
  }),
},
async input => {
  const drug = await getDrugByName(input.drugName);
  if (!drug) {
    throw new Error(`Drug with name ${input.drugName} not found in DrugBank.`);
  }
  return drug;
}
);

const prompt = ai.definePrompt({
  name: 'analyzeDrugCandidatePrompt',
  tools: [pubChemTool, drugBankTool],
  input: {
    schema: z.object({
      smiles: z.string().describe('The SMILES string of the drug candidate.'),
      targetProtein: z.string().optional().describe('The optional target protein for the analysis.'),
      query: z.string().describe('The analysis query from the user.'),
    }),
  },
  output: {
    schema: z.object({
      analysis: z.string().describe('The analysis of the drug candidate.'),
    }),
  },
  prompt: `You are an expert pharmaceutical researcher specializing in early-stage drug discovery analysis.

  A user has submitted a drug candidate for analysis.
  SMILES String: {{{smiles}}}
  {{#if targetProtein}}Target Protein: {{{targetProtein}}}{{/if}}
  User Query: {{{query}}}

  Instructions:
  1.  First, use the 'getMoleculeBySmiles' tool to retrieve basic chemical properties (like molecular weight, formula, IUPAC name if available) for the provided SMILES string. Reference this information in your analysis.
  2.  If the molecule has an IUPAC name, consider using the 'getDrugByName' tool with that name (or parts of it) to see if it corresponds to a known drug in DrugBank. Also use this tool if the user's query explicitly mentions a known drug name. Integrate any relevant findings from DrugBank (like description or known uses) into your analysis.
  3.  Address the user's specific query: "{{{query}}}".
  4.  If a target protein ({{{targetProtein}}}) was provided, specifically discuss the potential interaction, binding affinity (qualitatively if no data is available), or suitability of the candidate for this target, based on its structure and properties obtained from the tools. If no target was provided, focus on general properties, potential applications, or risks based on the query.
  5.  Provide a concise yet informative analysis. Structure your response clearly. Include potential strengths, weaknesses, or areas for further investigation based on the available data.
  6.  If the PubChem tool fails or returns no data for the SMILES string, state that clearly and indicate that the analysis is limited due to the lack of basic chemical information. You cannot proceed effectively without molecule data.
  7.  If the DrugBank tool fails or finds no match for a name derived from PubChem or mentioned by the user, mention that the compound doesn't appear to be a registered drug under that name in the available data.

  Return only the final analysis as a single string in the 'analysis' field.
`,
});


const analyzeDrugCandidateFlow = ai.defineFlow<
  typeof AnalyzeDrugCandidateInputSchema,
  typeof AnalyzeDrugCandidateOutputSchema
>({
  name: 'analyzeDrugCandidateFlow',
  inputSchema: AnalyzeDrugCandidateInputSchema,
  outputSchema: AnalyzeDrugCandidateOutputSchema,
}, async input => {
  const {output} = await prompt(input);
  return output!;
});
